/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2210 from the
 * contents of HyperLogLog.xs. Do not edit this file, edit HyperLogLog.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "lib/Algorithm/HyperLogLog.xs"
#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "ppport.h"
#include "murmur3.h"

#define MAGIC 1
#define HLL_HASH_SEED 313

typedef struct HyperLogLog {
    uint32_t m;
    uint8_t k;
    char* registers;
    double alphaMM;
}*HLL;

#define GET_HLLPTR(x) get_hll(aTHX_ x, "$self")

static const double two_32 = 4294967296.0;
static const double neg_two_32 = -4294967296.0;

static HLL get_hll(pTHX_ SV* object, const char* context) {
    SV *sv;
    HV *stash, *class_stash;
    IV address;

    if (MAGIC) SvGETMAGIC(object);
    if (!SvROK(object)) {
        if (SvOK(object)) croak("%s is not a reference", context);
        croak("%s is undefined", context);
    }
    sv = SvRV(object);
    if (!SvOBJECT(sv)) croak("%s is not an object reference", context);
    stash = SvSTASH(sv);
    /* Is the next even possible ? */
    if (!stash) croak("%s is not a typed reference", context);
    class_stash = gv_stashpv("Algorithm::HyperLogLog", FALSE);
    //if (!my_isa_lookup(aTHX_ stash, "Algorithm::HyperLogLog", class_stash, 22, 0)){
    if(!sv_derived_from(object,"Algorithm::HyperLogLog")) {
        croak("%s is not a Algorithm::HyperLogLog", context);
    }
    address = SvIV(sv);
    if (!address)
    croak("Algorithm::HyperLogLog object %s has a NULL pointer", context);
    return INT2PTR(HLL, address);
}

uint8_t rho(uint32_t x, uint8_t b) {
    uint8_t v = 1;
    while (v <= b && !(x & 0x80000000)) {
        v++;
        x <<= 1;
    }
    return v;
}

#line 68 "lib/Algorithm/HyperLogLog.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 120 "lib/Algorithm/HyperLogLog.c"

XS(XS_Algorithm__HyperLogLog_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Algorithm__HyperLogLog_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "class, k");
    {
#line 65 "lib/Algorithm/HyperLogLog.xs"
    HLL hll;
    double alpha  = 0.0;
#line 136 "lib/Algorithm/HyperLogLog.c"
	SV *	RETVAL;
	const char *	class = (const char *)SvPV_nolen(ST(0));
	uint32_t	k = (uint32_t)SvIV(ST(1));
#line 68 "lib/Algorithm/HyperLogLog.xs"
{
    New(__LINE__, hll, 1, struct HyperLogLog);
    if( k < 4 || k > 16 ) {
        croak("Number of ragisters must be in the range [4,16]");
    }
    hll->k = k;
    hll->m = 1 << hll->k;
    hll->registers = (char *)malloc(hll->m * sizeof(uint8_t));
    memset(hll->registers, 0, hll->m);

    switch (hll->m) {
        case 16:
        alpha = 0.673;
        break;
        case 32:
        alpha = 0.697;
        break;
        case 64:
        alpha = 0.709;
        break;
        default:
        alpha = 0.7213/(1.0 + (1.079/(double) hll->m));
        break;
    }
    hll->alphaMM = alpha * hll->m * hll->m;

    RETVAL = sv_newmortal();
    sv_setref_pv(RETVAL, class, (void *) hll);
    (void)SvREFCNT_inc(RETVAL);
}
#line 171 "lib/Algorithm/HyperLogLog.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Algorithm__HyperLogLog_add); /* prototype to pass -Wmissing-prototypes */
XS(XS_Algorithm__HyperLogLog_add)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, str");
    {
#line 104 "lib/Algorithm/HyperLogLog.xs"
    uint32_t hash;
    uint32_t index;
    uint8_t rank;
#line 194 "lib/Algorithm/HyperLogLog.c"
	HLL	self = GET_HLLPTR(ST(0));
	const char*	str = (const char *)SvPV_nolen(ST(1));
#line 108 "lib/Algorithm/HyperLogLog.xs"
{
    MurmurHash3_x86_32((void *) str, strlen(str), HLL_HASH_SEED, (void *) &hash);
    index = (hash >> (32 - self->k));
    rank = rho( (hash << self->k), 32 - self->k );
    if( rank > self->registers[index] ) {
        self->registers[index] = rank;
    }
}
#line 206 "lib/Algorithm/HyperLogLog.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Algorithm__HyperLogLog_estimate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Algorithm__HyperLogLog_estimate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	double	RETVAL;
	dXSTARG;
	HLL	self = GET_HLLPTR(ST(0));
#line 120 "lib/Algorithm/HyperLogLog.xs"
{
    double estimate;
    uint32_t m = self->m;
    uint32_t i = 0;
    uint32_t rank = 0;
    double sum = 0.0;
    for (i = 0; i < m; i++) {
        rank = self->registers[i];
        sum += 1.0/pow(2.0, rank);
    }
    estimate = self->alphaMM/sum; // E in the original paper
    if( estimate <= 2.5 * m ) {
        uint32_t zeros = 0;
        uint32_t i = 0;
        for (i = 0; i < m; i++) {
            if (self->registers[i] == 0) {
                zeros++;
            }
        }
        if( zeros != 0 ) {
            estimate = m * log((double)m/zeros);
        }
    } else if (estimate > (1.0/30.0) * two_32) {
        estimate = neg_two_32 * log(1.0 - ( estimate/two_32 ) );
    }

    RETVAL = estimate;
}
#line 255 "lib/Algorithm/HyperLogLog.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Algorithm__HyperLogLog_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Algorithm__HyperLogLog_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	HLL	self = GET_HLLPTR(ST(0));
#line 154 "lib/Algorithm/HyperLogLog.xs"
{
    Safefree(self->registers);
    Safefree (self);
}
#line 279 "lib/Algorithm/HyperLogLog.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Algorithm__HyperLogLog); /* prototype to pass -Wmissing-prototypes */
XS(boot_Algorithm__HyperLogLog)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK ;

        newXS("Algorithm::HyperLogLog::new", XS_Algorithm__HyperLogLog_new, file);
        newXS("Algorithm::HyperLogLog::add", XS_Algorithm__HyperLogLog_add, file);
        newXS("Algorithm::HyperLogLog::estimate", XS_Algorithm__HyperLogLog_estimate, file);
        newXS("Algorithm::HyperLogLog::DESTROY", XS_Algorithm__HyperLogLog_DESTROY, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

